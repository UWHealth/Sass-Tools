@import 'typography/variables';

/// Wrapper for Sass' internal `get-function` that allows for compatibility across Sass versions. If version is higher than 3.5, then the function is returned, otherwise, just the name.
/// @link https://github.com/kaelig/sass-safe-get-function
/// @group utils
@function safe-get-function($name) {
    @if function-exists('get-function') {
        @return get-function($name);
    } @else {
        @return $name;
    }
}

/// Holds all cached function calls.
/// @type Map
$_cached-values: ();

/// Memoize (cache) a function's return values and arguments. Speeds up processing on intensive functions that get called many times (with the same arguments).
/// _NOTE: This can actually **increase** processing time if used too often or on simple functions as the lookup process isn't free. Every cached value is unique._
/// @param {string} $function-name
/// @param {} $args... - Arguments to be passed to the function
/// @group utils
@function cache($function-name, $args...) {
    $cache-map: '#{$function-name}, #{$args}';
    $value: map-get($_cached-values, $cache-map);

    @if $value != null and $value != '' {
        @return $value;
    } @else {
        $result: call(safe-get-function($function-name), $args...);
        $_cached-values: map-merge($_cached-values, ($cache-map: $result)) !global;
        @return $result;
    }
}

/// Remove lengths (`px`, `em`, `rem`, etc.) from a value. Usually a variable. This is sometimes required because Sass cannot calculate incompatible units (`px * rem` for instance).
/// @param {Length} $value
/// @group utils
@function strip-units($value) {
    @return $value / ($value * 0 + 1);
}

/// Changes percent value to decimal.
/// @param {Number} $percentage
/// @group utils
@function percentage-to-decimal($percentage) {
    @if unit($percentage) == '%' {
        $percentage: $percentage/100%;
    }
    @return $percentage;
}

/// Converts pixel dimensions to viewport width (vw) dimensions.
/// @param {number} $pixels
/// @returns {number}
/// @group utils
@function px-to-vw($pixels) {
    $vw-context: ($max-site-width * .01) * 1px;
    @return ($pixels / $vw-context) * 1vw;
}

/// Converts a list to a string with an optional separator.
/// @param {list} $list
/// @param {string} $separator [',']
/// @returns {string}
/// @group utils
@function list-to-string($list, $separator: ",") {
    $string: "";

    @for $i from 1 through length($list) {
        $string: str-append($string, #{nth($list, $i)});

        @if $i != length($list) {
            $string: str-append($string, $separator);
        }
    }

    @return $string;
}

/// Converts a number-like string to a number. Since Sass accepts quoted and non-quoted values like `"10px"` and `10px`, but can only do math on the unquoted (number) value, it is sometimes necessary to convert/cast a string to a number.
/// @group utils
/// @param {string} $string
/// @param {boolean} $unitless [false]
/// @returns {number}

@function str-to-number($string, $unitless: false){
    //Maps to check against
    $str-numbers:('0':0,'1':1,'2':2,'3':3,'4':4,'5':5,'6':6,'7':7,'8':8,'9':9);
    //Leading 0 allows us to loop backwards without reaching null
    $string: 0 + $string;

    $total: 0;
    $decimal: 1;
    $negative: 1;
    $number-found: false;
    $unit: -1;

    //Loop backwards through string until a number is found
    @while not $number-found {

        //Break if loop is longer than string, or longer than any possible unit value
        @if (($unit * -1) >= str-length($string)) or $unit < -6 {
            $unit: -2;
            //set unitless to true regardless of user input.
            $unitless: true;
            $number-found: 1;
        }

        $slice: str-slice($string, $unit, $unit);
        $number-found: map-get($str-numbers, $slice);
        $unit:  $unit - 1;

    }
    //Compensate for Sass' non-zero
    $unit: $unit + 1;
    $value: str-slice($string, 1, $unit);
    $str-length: str-length($value);

    //Just return value if it's length is 2
    @if $str-length == 2 {
        @return map-get($str-numbers, str-slice($string, 2));
    }

    //Loop forward through string
    @for $i from 1 through $str-length {
        //Slice at each value
        $sub-string: str-slice($value, $i, $i);
        //Check for known number, convert to real number
        $number: map-get($str-numbers, $sub-string);

        @if $number {
            //multiply total by ten to give us proper number placement
            $total: $total * 10 + $number;

        }@else if $sub-string == '-' {
            //check for negative
            $negative: -1;

        }@else if $sub-string == '.' {
            //check for decimal
            $decimal-pos: $str-length - $i;
            //Create a number to multiply by to recreate decimal
            @for $j from 1 through $decimal-pos {
                $decimal: $decimal * 0.1;
            }
        }
    }

    @if $unitless or $unit == -1 {
        $unit: 1;
    } @else {
        $str-units: (
            'px':1px,'%':1%,'em':1em,'rem':1rem,'ex':1ex,
            'cm':1cm,'mm':1mm,'ch':1ch,'pica':1pica,'in':1in,'pt':1pt,'pc':1pc,
            'vw':1vw,'vh':1vh,'vmin':1vmin,'vmax':1vmax
        );
        $unit-str: str-slice($string, ($unit + 1), -1);
        $unit: map-get($str-units, $unit-str);

        @if not $unit {
            @warn "#{$unit-str} is not a valid CSS unit.";
            $unit: 1;
        }
    }
    //Take number and multiply it as necessary to achieve original.
    @return ($total * $decimal)* $negative * $unit;
}

/// Convert a value to a list. `$keep` accepts `'keys'`, `'values'`, or `'both'` for map conversion.
/// @group utils
/// @param {any} $value
/// @param {string} $keep - accepts `'keys'`, `'values'`, or `'both'` for map conversion.
@function to-list($value, $keep: "both") {
    $keep: if(index("keys" "values" "both", $keep), $keep, "both");

    @if type-of($value) == "map" {
        $keys: ();
        $values: ();

        @each $key, $val in $value {
            $keys: append($keys, $key);
            $values: append($values, $val);
        }

        @if $keep == "keys" {
            @return $keys;
        }
        @else if $keep == "values" {
            @return $values;
        }
        @else {
            @return zip($keys, $values);
        }
    }

    @return if(type-of($value) != list, ($value,), $value);
}


/// Generic `contains` function(similar to javascript's `indexOf`). Parses a variable(`$data`) for a `$value`. Returns boolean. Delegates methods to the appropriate function based on variable type.
/// @group utils
/// @param {map | list | string} $data - the data you're searching through.
/// @param {} $value - the value you're searching for.
@function contains($data, $value){
    @if type-of($data == "map"){
        @return map-has-keys($data, $value);
    }@else if type-of($data == "list"){
        @return list-contains($data, $value);
    }@else if type-of($data == "string"){
        @return str-contains($data, $value);
    }
}


/// Converts a map or list to a string (`('this', 'and', 'this')` becomes `'this,and,this'`).
/// @group utils
/// @param {list | map} $list
/// @param {string} $separator [","]
@function str-join($list, $separator: ",") {
    @return list-to-string($list, $separator);
}

/// Checks if a `$string` contains a `$value`. Optionally accepts a start (`$pos`) positon.
/// @group utils
/// @param {string} $string
/// @param {string} $value
/// @param {number} $pos [0]
@function str-contains($string, $value, $pos: 0) {

    $string: str-slice($string, $pos);

    @if str-index($string, $value) != null {
        @return true;
    }
    @else {
        @return false;
    }
}

/// Adds one string to another (e.g. `str-append('hello', 'world')` becomes `hello world`).
/// @group utils
/// @param {string} $string
/// @param {string} $insert
@function str-append($string, $insert) {
    $string: if($string == null, '', $string);

    @return str-insert($string, $insert, str-length($string) + 1);
}

/// Replaces a value in a string with another.
/// @group utils
@function str-replace($string, $search, $replace: '') {
    $index: str-index($string, $search);

    @if $index {
        @return str-slice($string, 1, $index - 1) + $replace + str-replace(str-slice($string, $index + str-length($search)), $search, $replace);
    }

    @return $string;
}


/// Check if a list contains a value
/// @group utils
/// @param $list
/// @param $value
@function list-contains($list, $value) {
    @return not not index($list, $value);
}

/// Reverse a List
/// @group utils
/// @param $list
/// @param $recursive [false]
@function list-reverse($list, $recursive: false) {
    $result: ();

    @for $i from length($list)*-1 through -1 {
        @if type-of(nth($list, abs($i))) == list and $recursive {
            $result: append($result, reverse(nth($list, abs($i)), $recursive));
        }
        @else {
            $result: append($result, nth($list, abs($i)));
        }
    }

    @return $result;
}

/// List print
/// @group utils
/// @param $list
/// @param $depth [1]
@function list-print($list, $depth: 1) {
    $output: '';

    @if $depth > 0 {
        @for $i from 1 through $depth {
            $output: $output + $list;
        }
    }

    @return $output;
}


/// Add to a deeply nested map key. Accepts any number of keys, but the final value is the new key.
/// @group utils
/// @param {map} $map
/// @param {string} $keys... - final argument is considered the value to the be set.
@function map-deep-set($map, $keys... /*, $value */) {
    $map-list: ($map,);
    $result: null;

    @if length($keys) == 2 {
        @return map-merge($map, (nth($keys, 1): nth($keys, -1)));
    }

    @for $i from 1 through length($keys) - 2 {
        $map-list: append($map-list, map-get(nth($map-list, -1), nth($keys, $i)));
    }

    @for $i from length($map-list) through 1 {
        $result: map-merge(nth($map-list, $i), (nth($keys, $i): if($i == length($map-list), nth($keys, -1), $result)));
    }

    @return $result;
}


/// Finds a map's depth at its deepest point. Useful for debugging maps.
/// @group utils
/// @param {map} $map
/// @returns {number}
@function map-depth($map) {
    $level: 1;

    @each $key, $value in $map {
        @if type-of($value) == "map" {
            $level: max(map-depth($value) + 1, $level);
        }
    }

    @return $level;
}

/// Determine whether a map contains certain keys.
/// @group utils
/// @param {map} $map
/// @param {string | list} $keys...
/// @returns {boolean}
@function map-has-keys($map, $keys...) {
    @each $key in $keys {
        @if not map-has-key($map, $key) {
            @return false;
        }
    }

    @return true;
}

/// @alias map-has-keys
/// @group utils
@function map-contains-keys($map, $keys...) {
    @return map-has-keys($map, $keys);
}

/// Check for deep map keys
/// @group utils
/// @param {map} $map
/// @param {string | list} $keys...
@function map-has-nested-keys($map, $keys...) {
    @each $key in $keys {
        @if not map-has-key($map, $key) {
            @return false;
        }

        $map: map-get($map, $key);
    }

    @return true;
}
/// @alias map-has-nested-keys
/// @group utils
@function map-contains-nested-keys($map, $keys...) {@return map-has-nested-keys($map, $keys);}

/// Get map value at nested or 'deep' key, per $keys list
/// @group utils
/// @param {map} $map
/// @param {string|list} $keys...
@function map-get-nested($map, $keys...) {
    @each $key in $keys {
        @if type-of($map) != 'map' {
            @return $map;
        }
        $map: map-get($map, $key);
    }
    @return $map;
}

/// Merges multiple maps. Similar to jQuery's `extend`.
/// Takes two maps and merges their differences.
/// @group utils
/// @param {map} $map
/// @param {map|list} $maps... - final value can be `true` for "deep" merging
@function map-extend($map, $maps... /*, $deep */) {
    $last: nth($maps, -1);
    $deep: $last == true;
    $max: if($deep, length($maps) - 1, length($maps));

    // Loop through all maps in $maps...
    @for $i from 1 through $max {
        // Store current map
        $current: nth($maps, $i);

        // If not in deep mode, simply merge current map with map
        @if not $deep {
            $map: map-merge($map, $current);
        } @else {
            // If in deep mode, loop through all tuples in current map
            @each $key, $value in $current {

                // If value is a nested map and same key from map is a nested map as well
                @if type-of($value) == "map" and type-of(map-get($map, $key)) == "map" {
                    // Recursive extend
                    $value: map-extend(map-get($map, $key), $value, true);
                }

                // Merge current tuple with map
                $map: map-merge($map, ($key: $value));
            }
        }
    }

    @return $map;
}


//Map depth-adder
//-------------------------
// Adds 'base'(or whatever initial key that's passed in) to a color map.
// Used by color map generator function (colors/_colorfunctions)
//--------------------------
// 1. Check if map is less than or equal to the depth tolerance (default: 1).
// 2. loops through all keys and values in the map.
// 3. Make sure value isn't alreayd a map
//   3a. If value is a map, then check to make sure $new-key is in the map
//     3b. Duplicate first value of map (in case there are multiple)
//     3c. Create new map with new-key and duplicated value
// 4. Reformats those key-value pairs into a (key: (new-key: value ))
// 5. Merges new depthy key-key-value back into the map.
// 6. Returns the new map.

/// Adds one level to a map using the new key to a map. Used by `generate_color_varations()`. (e.g. `(key: value, key: value)` becomes `(key:(new-key: value), key:(new-key: value))` )
/// @group utils
/// @param {map} $map
/// @param {string} $new-key ['base']
@function map-add-depth($map, $new-key: 'base'){
    $formatted-key:();
    $new-map:'';

    @each $key, $value in $map {                 //[2]
        $formatted-key: ();
        @if type-of($value) != "map" {                      //[3]
            $formatted-key: ($key: ($new-key: $value));     //[4]

        }@else if not map-has-key($value, $new-key) {       //[3a]
            $duplicate-value: map-get($value, nth(map-keys($value), 1)); //[3b]
            $duplicate-map: ($new-key : $duplicate-value);               //[3c]

            $formatted-key: ($key: (map-merge($value, $duplicate-map))); //[4]
        }
        $map: map-merge($map, $formatted-key);        //[5]
    }

    @return $map;                                     //[6]
}


/// Print maps into a string
/// @group utils
/// @param {map} $map
/// Useful for debugging maps.
/// @link https://github.com/lunelson/sass-maps-plus
@function map-inspect($map, $level: 1) {
    $tab: '    ';
    $cr: '
';

    @if type-of($map) != 'map' {
        @return '#{inspect($map)}';
    }

    $indent: list-print($tab, $level + 1);
    $output: '{' + $cr + $indent; $i: 1;

    @each $key, $value in $map {
        @if type-of($value) == 'map' {
            $output: $output + '#{$key}: #{map-inspect($value, $level+1)}';
        } @else {
            $output: $output + '#{$key}: #{$value}';
        }

        @if $i < length(map-keys($map)) {
            $output: $output + ',' + $cr + $indent;
        }

        $i: $i + 1;
    }

    $outdent: list-print($tab, $level);

    @return $output + $cr + $outdent + '}';
}

/// @alias map-inspect
/// @group utils
@function map-print($map, $level: 1){
    @return map-inspect($map, $level);
}

/// Add to silent classes registry
/// @group utils
@function silents-register($map, $key){
    @if $debug-silent-classes {
        @if map-get($_silent-class-registry, $key) == null {
            $_silent-class-registry: map-merge($_silent-class-registry, ($key:())) !global;
        }
        $map: map-merge(map-get($_silent-class-registry, $key), $map);
        @return map-deep-set($_silent-class-registry, $key, $map);
    } @else {
        @return null;
    }
}

// Global math constants
/// @group Math
$PI:    3.1415926535897932384626433832795028841971693993751;
$π:     $PI;
$pi:    $PI;
/// @group Math
$E:     2.71828182845904523536028747135266249775724709369995;
$e:     $E;
/// @group Math
$LN2:   0.6931471805599453;
/// @group Math
$SQRT2: 1.4142135623730951;

/// @group Math
/// @alias golden
$PHI: golden();

$golden_ratio: golden();

// MATH FUNCTIONS
//
// Most functions taken from [Sassy Math](https://github.com/Team-Sass/Sassy-math/blob/master/sass/math.scss).


/// A more robust exponent multiplication which allows for decimal-based exponents. This **fully** replaces Compass' pow() function (allows for float-based exponents).
/// @group Math
/// @param {number} $base
/// @param {number} $exp
/// @link https://gist.github.com/nathancrank/7539155
@function pow($base, $exp) {
    @if $exp == floor($exp) {
        $r: 1;
        $s: 0;
        @if $exp < 0 {
            $exp: $exp * -1;
            $s: 1;
        }
        @while $exp > 0 {
            @if $exp % 2 == 1 {
                $r: $r * $base;
            }
            $exp: floor($exp * 0.5);
            $base: $base * $base;
        }
        @return if($s != 0, 1 / $r, $r);
    } @else {
        $log: log($base);
        $exp: cache(exp, ($log * $exp));
        @return $exp;
    }
}

/// @alias pow
/// @group Math
@function exponent($base, $exponent) { @return pow($base, $exponent); }

/// Returns the natural logarithm of a number.
/// @param {number} $x
/// @group Math
/// @example
/// $value:   log(2)  // 0.69315
/// $value2:  log(10) // 2.30259
/// @returns {number}
@function log($x) {
    @if $x <= 0 {
        @return 0;
    }
    $k-frexp: frexp(($x / $SQRT2));
    $k: nth($k-frexp, 2);
    $x: $x / ldexp(1, $k);
    $x: ($x - 1) / ($x + 1);
    $x2: $x * $x;
    $i: 1;
    $s: $x;
    $sp: null;
    @while $sp != $s {
        $x: $x * $x2;
        $i: $i + 2;
        $sp: $s;
        $s: $s + $x / $i;
    }
    @return $LN2 * $k + 2 * $s;
}

/// Returns a two-element list containing the normalized fraction and exponent of number.
/// @group Math
/// @param $x
/// @returns {list} (fraction, exponent)
@function frexp($x) {
    $exp: 0;
    @if $x < 0 {
        $x: $x * -1;
    }
    @if $x < 0.5 {
        @while $x < 0.5 {
            $x: $x * 2;
            $exp: $exp - 1;
        }
    } @else if $x >= 1 {
        @while $x >= 1 {
            $x: $x / 2;
            $exp: $exp + 1;
        }
    }
    @return $x, $exp;
}


/// Returns `$x * 2^$exp`
/// @param {number} $x
/// @param {number} $exp
/// @group Math
/// @param $x
/// @param $exp
@function ldexp($x, $exp) {
    $b: if($exp >= 0, 2, 1 / 2);
    @if $exp < 0 {
        $exp: $exp * -1;
    }
    @while $exp > 0 {
        @if $exp % 2 == 1 {
            $x: $x * $b;
        }
        $b: $b * $b;
        $exp: floor($exp * 0.5);
    }
    @return $x;
}

/// Returns E^x, where x is the argument, and E is Euler's constant, the base of the natural logarithms.
/// @param {number} $x
/// @group Math
/// @example
/// $value: exp(1)  // 2.71828
/// $value2: exp(-1) // 0.36788
/// @returns {Number}
@function exp($x) {
    $ret: 0;
    @for $n from 0 to 24 {
        $ret: $ret + pow($x, $n) / fact($n);
    }
    @return $ret;
}

/// Returns the factorial of a non-negative integer.
/// @param {number} $x
/// @group Math
/// @example
/// $value:  fact(0) // 1
/// $value2: fact(8) // 40320
/// @return {Number}
@function fact($x) {
    @if $x < 0 or  $x != floor($x) {
        @warn "Argument for `fact()` must be a positive integer.";
        @return null;
    }

    $ret: 1;

    @while $x > 0 {
        $ret: $ret * $x;
        $x: $x - 1;
    }

    @return $ret;
}

/// Greatest Common Divisor calculation (useful for calculating grids and widths).
/// @group Math
/// @link http://rosettacode.org/wiki/Greatest_common_divisor#JavaScript
/// @param {number} $number-1
/// @param {number} $number-2
/// @returns {number}
@function gcd($number-1, $number-2) {
    @if $number-2 != 0 {
        @return gcd($number-2, ($number-1 % $number-2));
    }@else {
        @return abs($number-1);
    }
}


/// Find the square root of a value.
/// @group Math
/// @param {number} $base
/// @param {number} $precision [12]
@function sqrt($base, $precision: 12) {
    $guess: random(20);
    $root: $guess;

    @for $i from 1 through $precision {
        $root: $root - (pow($root, 2) - $base) / (2 * $root);
    }
    @return $root;
}

/// @alias sqrt
/// @param $r
/// @group Math
@function sqroot($r) {
    $x0: 1; // initial value
    $solution: false;
    $x1: 1;

    @for $i from 1 through 10 {
        @if abs(2 * $x0) < 0.00000000000001 { // Don't want to divide by a number smaller than this
            $solution: false;
        }

        $x1: $x0 - ($x0 * $x0 - abs($r)) / (2 * $x0);

        @if ( abs($x1 - $x0) / abs($x1)) < 0.0000001 { // 7 digit accuracy is desired
            $solution: true;
        }

        $x0: $x1;
    }

    @if $solution == true {
    // If $r is negative, then the output will be multiplied with
    // [i = √-1](http://en.wikipedia.org/wiki/Imaginary_number)
    // (√xy = √x√y) => √-$r = √-1√$r
        @if $r < 0 {
            @return $x1 #{i};
        }
        @else {
            @return $x1;
        }
    }
    @else {
        @return "No solution";
    }
}


/// Determines the Sine of an angle.
/// [Reference](https://unindented.org/articles/trigonometry-in-sass/)
/// @group Math
/// @param $angle
/// @returns {number}
@function sin($angle) {
    $sin: 0;
    $angle: rad($angle);
    // Iterate a bunch of times.
    @for $i from 0 through 10 {
        $sin: $sin + pow(-1, $i) * pow($angle, (2 * $i + 1)) / fact(2 * $i + 1);
    }
    @return $sin;
}

// Hyperbolic sine
// @param $number
// @group Math
// @function sinh($number) {
//     $top: exponent($e, (2 * $number)) - 1;
//     $bottom: 2 * exponent($e, $number);
//     @return  $top / $bottom;
// }


// Determines the Cosine of an angle.
// @group Math
// @param $angle
// @returns {number}
// @function cos($angle) {
//     $cos: 0;
//     $angle: rad($angle);
//     // Iterate a bunch of times.
//     @for $i from 0 through 10 {
//         $cos: $cos + pow(-1, $i) * pow($angle, 2 * $i) / fact(2 * $i);
//     }
//     @return $cos;
// }


/// Get the golden ratio from `$base`.
/// @group Math
/// @param {} $base [1]
/// @returns {number}
@function golden($base: 1) {
    @return (1/2 + sqrt(5) / 2) * $base;
}

/// @param $angle
/// @group Math
@function rad($angle) {
    $unit: unit($angle);
    $unitless: $angle / ($angle * 0 + 1);
    // If the angle has 'deg' as unit, convert to radians.
    @if $unit == deg {
        $unitless: $unitless / 180 * $pi;
    }
    @return $unitless;
}

/// @alias rad
/// @param $angle
/// @group Math
@function angle-to-rad($angle) {
    @return rad($angle);
}


// Math helpers

@function quarter($number) {
    @return round($number / 4);
}

@function halve($number) {
    @return round($number / 2);
}

@function double($number) {
    @return round($number * 2);
}

@function quadruple($number) {
    @return round($number * 4);
}
