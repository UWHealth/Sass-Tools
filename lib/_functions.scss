//stylelint-disable
@function _legacy-check($new-var, $old-var, $default) {
    @if ($old-var != $default) {
        @return $old-var;
    }
    @return $new-var;
}

/// Wrapper for Sass' internal `get-function` that allows for compatibility across Sass versions. If version is higher than 3.5, then the function is returned, otherwise, just the name.
/// @param {string} $name - function name
/// @link https://github.com/kaelig/sass-safe-get-function
/// @group utils
///
@function safe-get-function($name) {
    @if function-exists('get-function') {
        @return get-function($name);
    } @else {
        @return $name;
    }
}

/// Wrapper for Sass' internal `call` that allows for compatibility across Sass versions. If version is higher than 3.5, then the function is returned, otherwise, just the name.
/// @param {string} $name - function name
/// @param {any} $args... - function arguments
/// @group utils
///
@function safe-call($name, $args...) {
    @return call(safe-get-function($name), $args...);
}

/// Holds all cached function calls.
/// @type Map
$_cached-values: ();

/// Memoize (cache) a function's return values and arguments. Speeds up processing on intensive functions that get called many times (with the same arguments).
/// _NOTE: This can actually **increase** processing time if used too often or on simple functions as the lookup process isn't free. Every cached value is unique._
/// @param {string} $function-name
/// @param {} $args... - Arguments to be passed to the function
/// @group utils
///
@function cache($function-name, $args...) {
    $cache-map: '#{$function-name}, #{$args}';
    $value: map-get($_cached-values, $cache-map);

    @if $value != null and $value != '' {
        @return $value;
    } @else {
        $result: call(safe-get-function(#{$function-name}), $args...);
        $_cached-values: map-merge(
            $_cached-values,
            (
                $cache-map: $result
            )
        ) !global;
        @return $result;
    }
}

/// Remove lengths (`px`, `em`, `rem`, etc.) from a value. Usually a variable. This is sometimes required because Sass cannot calculate incompatible units (`px * rem` for instance).
/// @param {Length} $value
/// @group utils
@function strip-units($value) {
    @return $value / ($value * 0 + 1);
}

/// Changes percent value to decimal.
/// @param {Number} $percentage
/// @group utils
///
@function percentage-to-decimal($percentage) {
    @if unit($percentage) == "%" {
        $percentage: ($percentage/100%);
    }
    @return $percentage;
}

/// Calculates `rem` values. Used by `px-to-rems` mixin. The `$base-size` is used to calculate the value (e.g. if the body's font-size is `16px`, then the rem value of `24px` would be `1.5rem`).
/// @group core
/// @param {Number} $pixels
///
@function px-to-rems($pixels, $base-size: $base-font-size) {
    @if $pixels == 'auto' or $pixels == 'normal' {
        @return $pixels;
    }

    @if (unitless($pixels)) {
        $pixels: $pixels * 1px;
    }

    //If 0, don't include units
    @if $pixels == 0px {
        @return 0;
    }

    $pixels: ($pixels / $base-size) * 1rem;

    @return $pixels;
}

/// @alias px-to-rems
///
@function rems($pixels, $base-size: $base-font-size) {
    @return px-to-rems($pixels, $base-size);
}

/// Function for calculating `em` values. The `$context` is used to calculate the final value. Different from `px-to-rems()` by generating a value with an `em`. `$context` is often necessary based on the situation.
/// @group core
/// @param {Number} $pixels
/// @param {Number} $context [$base-font-size]
///
@function px-to-ems($pixels, $context: $base-font-size) {
    @if (unitless($pixels)) {
        $pixels: $pixels * 1px;
    }

    //If 0, don't include rems
    @if $pixels == 0px {
        @return 0;
    }

    $pixels: ($pixels / $context) * 1em;

    @return $pixels;
}

/// @alias px-to-ems
///
@function ems($pixels, $context: $base-font-size) {
    @return px-to-ems($pixels, $context);
}

/// Converts pixel dimensions to viewport width (vw) dimensions.
/// @param {number} $pixels
/// @returns {number}
/// @group utils
///
@function px-to-vw($pixels) {
    $vw-context: ($max-site-width * 0.01) * 1px;
    @return ($pixels / $vw-context) * 1vw;
}

/// Converts a list to a string with an optional separator.
/// @param {list} $list
/// @param {string} $separator [',']
/// @returns {string}
/// @group utils
///
@function list-to-str($list, $separator: ",") {
    $string: "";

    @for $i from 1 through length($list) {
        $string: str-append($string, #{nth($list, $i)});

        @if $i != length($list) {
            $string: str-append($string, $separator);
        }
    }

    @return $string;
}

/// Casts a string into a number.
/// @author Hugo Giraudel
/// @group utils
///
/// @param {String | Number} $value - Value to be parsed
/// @return {Number}
///
@function str-to-number($value) {
    @if type-of($value) == "number" {
        @return $value;
    } @else if type-of($value) != "string" {
        @warn 'Value for `to-number` should be a number or a string.';
    }

    $result: 0;
    $digits: 0;
    $minus: str-slice($value, 1, 1) == "-";
    $numbers: (
        "0": 0,
        "1": 1,
        "2": 2,
        "3": 3,
        "4": 4,
        "5": 5,
        "6": 6,
        "7": 7,
        "8": 8,
        "9": 9
    );

    @for $i from if($minus, 2, 1) through str-length($value) {
        $character: str-slice($value, $i, $i);

        @if not(index(map-keys($numbers), $character) or $character == ".") {
            @return to-length(
                if($minus, -$result, $result),
                str-slice($value, $i)
            );
        }

        @if $character == "." {
            $digits: 1;
        } @else if $digits == 0 {
            $result: $result * 10 + map-get($numbers, $character);
        } @else {
            $digits: $digits * 10;
            $result: $result + map-get($numbers, $character) / $digits;
        }
    }

    @return if($minus, -$result, $result);
}

/// Add `$unit` to `$value`
/// @author Hugo Giraudel
/// @group utils
///
/// @param {Number} $value - Value to add unit to
/// @param {String} $unit - String representation of the unit
/// @return {Number} - `$value` expressed in `$unit`
///
@function to-length($value, $unit) {
    $units: (
        "px": 1px,
        "cm": 1cm,
        "mm": 1mm,
        "%": 1%,
        "ch": 1ch,
        "pc": 1pc,
        "in": 1in,
        "em": 1em,
        "rem": 1rem,
        "pt": 1pt,
        "ex": 1ex,
        "vw": 1vw,
        "vh": 1vh,
        "vmin": 1vmin,
        "vmax": 1vmax
    );

    @if not index(map-keys($units), $unit) {
        @warn 'Invalid unit `#{$unit}`.';
    }

    @return $value * map-get($units, $unit);
}

/// Convert a value to a list. `$keep` accepts `'keys'`, `'values'`, or `'both'` for map conversion.
/// @group utils
/// @param {any} $value
/// @param {string} $keep - accepts `'keys'`, `'values'`, or `'both'` for map conversion.
///
@function to-list($value, $keep: "both") {
    $keep: if(index("keys" "values" "both", $keep), $keep, "both");

    @if type-of($value) == "map" {
        $keys: ();
        $values: ();

        @each $key, $val in $value {
            $keys: append($keys, $key);
            $values: append($values, $val);
        }

        @if $keep == "keys" {
            @return $keys;
        } @else if $keep == "values" {
            @return $values;
        } @else {
            @return zip($keys, $values);
        }
    }

    @return if(type-of($value) != list, ($value), $value);
}

/// Generic `contains` function(similar to javascript's `indexOf`). Parses a variable(`$data`) for a `$value`. Returns boolean. Delegates methods to the appropriate function based on variable type.
/// @group utils
/// @param {map | list | string} $data - the data you're searching through.
/// @param {} $value - the value you're searching for.
///
@function contains($data, $value) {
    @if type-of($data == "map") {
        @return map-has-keys($data, $value);
    } @else if type-of($data == "list") {
        @return list-contains($data, $value);
    } @else if type-of($data == "string") {
        @return str-contains($data, $value);
    }
}

/// Converts a map or list to a string (`('this', 'and', 'this')` becomes `'this,and,this'`).
/// @group utils
/// @param {list | map} $list
/// @param {string} $separator [","]
///
@function str-join($list, $separator: ",") {
    @return list-to-str($list, $separator);
}

/// Checks if a `$string` contains a `$value`. Optionally accepts a start (`$pos`) positon.
/// @group utils
/// @param {string} $string
/// @param {string} $value
/// @param {number} $pos [0]
///
@function str-contains($string, $value, $pos: 0) {
    $string: str-slice($string, $pos);

    @if str-index($string, $value) != null {
        @return true;
    } @else {
        @return false;
    }
}

/// Adds one string to another (e.g. `str-append('hello', 'world')` becomes `hello world`).
/// @group utils
/// @param {string} $string
/// @param {string} $insert
///
@function str-append($string, $insert) {
    $string: if($string == null, "", $string);

    @return str-insert($string, $insert, str-length($string) + 1);
}

/// Replaces a value in a string with another.
/// @group utils
///
@function str-replace($string, $search, $replace: "") {
    $index: str-index($string, $search);

    @if $index {
        @return str-slice($string, 1, $index - 1) + $replace +
            str-replace(
                str-slice($string, $index + str-length($search)),
                $search,
                $replace
            );
    }

    @return $string;
}

/// Split a string into a list of strings
/// @link https://gist.github.com/danielpchen/3677421ea15dcf2579ff
/// @param {string} $string - the string to be split
/// @param {string} $delimiter - the boundary string
/// @return {list} - the result list
///
@function str-to-list($string, $delimiter) {
    $result: ();
    @if $delimiter == "" {
        @for $i from 1 through str-length($string) {
            $result: append($result, str-slice($string, $i, $i));
        }
        @return $result;
    }
    $exploding: true;
    @while $exploding {
        $d-index: str-index($string, $delimiter);
        @if $d-index {
            @if $d-index > 1 {
                $result: append($result, str-slice($string, 1, $d-index - 1));
                $string: str-slice($string, $d-index + str-length($delimiter));
            } @else if $d-index == 1 {
                $string: str-slice(
                    $string,
                    1,
                    $d-index + str-length($delimiter)
                );
            } @else {
                $result: append($result, $string);
                $exploding: false;
            }
        } @else {
            $result: append($result, $string);
            $exploding: false;
        }
    }
    @return $result;
}

/// @alias str-to-list
/// @group utils
///
@function explode($string, $delimiter) {
    @return str-to-list($string, $delimiter);
}

/// Check if a list contains a value
/// @group utils
/// @param $list
/// @param $value
///
@function list-contains($list, $value) {
    @return not not index($list, $value);
}

/// Reverse a List
/// @group utils
/// @param $list
/// @param $recursive [false]
///
@function list-reverse($list, $recursive: false) {
    $result: ();

    @for $i from length($list) * -1 through -1 {
        @if type-of(nth($list, abs($i))) == list and $recursive {
            $result: append($result, reverse(nth($list, abs($i)), $recursive));
        } @else {
            $result: append($result, nth($list, abs($i)));
        }
    }

    @return $result;
}

/// List print
/// @group utils
/// @param $list
/// @param $depth [1]
///
@function list-print($list, $depth: 1) {
    $output: "";

    @if $depth > 0 {
        @for $i from 1 through $depth {
            $output: $output + $list;
        }
    }

    @return $output;
}

/// Add to a deeply nested map key. Accepts any number of keys, but the final value is the new key.
/// @group utils
/// @param {map} $map
/// @param {string} $keys... - final argument is considered the value to the be set.
///
@function map-deep-set($map, $keys... /*, $value */) {
    $map-list: ($map);
    $result: null;

    @if length($keys) == 2 {
        @return map-merge(
            $map,
            (
                nth($keys, 1): nth($keys, -1)
            )
        );
    }

    @for $i from 1 through length($keys) - 2 {
        $map-list: append(
            $map-list,
            map-get(nth($map-list, -1), nth($keys, $i))
        );
    }

    @for $i from length($map-list) through 1 {
        $result: map-merge(
            nth($map-list, $i),
            (
                nth($keys, $i):
                    if($i == length($map-list), nth($keys, -1), $result)
            )
        );
    }

    @return $result;
}

/// Finds a map's depth at its deepest point. Useful for debugging maps.
/// @group utils
/// @param {map} $map
/// @returns {number}
///
@function map-depth($map) {
    $level: 1;

    @each $key, $value in $map {
        @if type-of($value) == "map" {
            $level: max(map-depth($value) + 1, $level);
        }
    }

    @return $level;
}

/// Determine whether a map contains certain keys.
/// @group utils
/// @param {map} $map
/// @param {string | list} $keys...
/// @returns {boolean}
///
@function map-has-keys($map, $keys...) {
    @each $key in $keys {
        @if not map-has-key($map, $key) {
            @return false;
        }
    }

    @return true;
}

/// @alias map-has-keys
/// @group utils
///
@function map-contains-keys($map, $keys...) {
    @return map-has-keys($map, $keys);
}

/// Check for deep map keys
/// @group utils
/// @param {map} $map
/// @param {string | list} $keys...
///
@function map-has-nested-keys($map, $keys...) {
    @each $key in $keys {
        @if not map-has-key($map, $key) {
            @return false;
        }

        $map: map-get($map, $key);
    }

    @return true;
}

/// @alias map-has-nested-keys
/// @group utils
///
@function map-contains-nested-keys($map, $keys...) {
    @return map-has-nested-keys($map, $keys);
}

/// Get map value at nested or 'deep' key, per $keys list
/// @group utils
/// @param {map} $map
/// @param {string|list} $keys...
///
@function map-get-nested($map, $keys...) {
    @each $key in $keys {
        @if type-of($map) != "map" {
            @return $map;
        }
        $map: map-get($map, $key);
    }
    @return $map;
}

/// Merges multiple maps. Similar to jQuery's `extend`.
/// Takes two maps and merges their differences.
/// @group utils
/// @param {map} $map
/// @param {map|list} $maps... - final value can be `true` for "deep" merging
///
@function map-extend($map, $maps... /*, $deep */) {
    $last: nth($maps, -1);
    $deep: $last == true;
    $max: if($deep, length($maps) - 1, length($maps));

    // Loop through all maps in $maps...
    @for $i from 1 through $max {
        // Store current map
        $current: nth($maps, $i);

        // If not in deep mode, simply merge current map with map
        @if not $deep {
            $map: map-merge($map, $current);
        } @else {
            // If in deep mode, loop through all tuples in current map
            @each $key, $value in $current {
                // If value is a nested map and same key from map is a nested map as well
                @if type-of($value) == "map" and
                    type-of(map-get($map, $key)) == "map"
                {
                    // Recursive extend
                    $value: map-extend(map-get($map, $key), $value, true);
                }

                // Merge current tuple with map
                $map: map-merge(
                    $map,
                    (
                        $key: $value
                    )
                );
            }
        }
    }

    @return $map;
}

//Map depth-adder
//-------------------------
// Adds 'base'(or whatever initial key that's passed in) to a color map.
// Used by color map generator function (colors/_colorfunctions)
//--------------------------
// 1. Check if map is less than or equal to the depth tolerance (default: 1).
// 2. loops through all keys and values in the map.
// 3. Make sure value isn't alreayd a map
//   3a. If value is a map, then check to make sure $new-key is in the map
//     3b. Duplicate first value of map (in case there are multiple)
//     3c. Create new map with new-key and duplicated value
// 4. Reformats those key-value pairs into a (key: (new-key: value ))
// 5. Merges new depthy key-key-value back into the map.
// 6. Returns the new map.

/// Adds one level to a map using the new key to a map. Used by `generate_color_varations()`. (e.g. `(key: value, key: value)` becomes `(key:(new-key: value), key:(new-key: value))` )
/// @group utils
/// @param {map} $map
/// @param {string} $new-key ['base']
///
@function map-add-depth($map, $new-key: "base") {
    $formatted-key: ();
    $new-map: "";

    @each $key, $value in $map {
        //[2]
        $formatted-key: ();
        @if type-of($value) != "map" {
            //[3]
            $formatted-key: (
                $key: (
                    $new-key: $value
                )
            ); //[4]
        } @else if not map-has-key($value, $new-key) {
            //[3a]
            $duplicate-value: map-get($value, nth(map-keys($value), 1)); //[3b]
            $duplicate-map: (
                $new-key: $duplicate-value
            ); //[3c]

            $formatted-key: (
                $key: (
                    map-merge($value, $duplicate-map)
                )
            ); //[4]
        }
        $map: map-merge($map, $formatted-key); //[5]
    }

    @return $map; //[6]
}

/// Print maps into a string
/// @group utils
/// @param {map} $map
/// Useful for debugging maps.
/// @link https://github.com/lunelson/sass-maps-plus
///
@function map-inspect($map, $level: 1) {
    $tab: "    ";
    $cr: "
";

    @if type-of($map) != "map" {
        @return "#{inspect($map)}";
    }

    $indent: list-print($tab, $level + 1);
    $output: "{" + $cr + $indent;
    $i: 1;

    @each $key, $value in $map {
        @if type-of($value) == "map" {
            $output: $output + "#{$key}: #{map-inspect($value, $level+1)}";
        } @else {
            $output: $output + "#{$key}: #{$value}";
        }

        @if $i < length(map-keys($map)) {
            $output: $output + "," + $cr + $indent;
        }

        $i: $i + 1;
    }

    $outdent: list-print($tab, $level);

    @return $output + $cr + $outdent + "}";
}

/// @alias map-inspect
/// @group utils
///
@function map-print($map, $level: 1) {
    @return map-inspect($map, $level);
}

/// Add to silent classes registry
/// @group utils
///
@function silents-register($map, $key) {
    @if $debug-silent-classes {
        @if map-get($_silent-class-registry, $key) == null {
            $_silent-class-registry: map-merge(
                $_silent-class-registry,
                (
                    $key: ()
                )
            ) !global;
        }
        $map: map-merge(map-get($_silent-class-registry, $key), $map);
        @return map-deep-set($_silent-class-registry, $key, $map);
    } @else {
        @return null;
    }
}

// Global math constants
/// @group Math
$PI: 3.1415926535897932384626433832795028841971693993751;
$π: $PI;
$pi: $PI;
/// @group Math
$E: 2.71828182845904523536028747135266249775724709369995;
$e: $E;
/// @group Math
$LN2: 0.6931471805599453;
/// @group Math
$SQRT2: 1.4142135623730951;

/// @group Math
/// @alias golden
$PHI: golden();

$golden_ratio: golden();

// MATH FUNCTIONS
//
// Most functions taken from [Sassy Math](https://github.com/Team-Sass/Sassy-math/blob/master/sass/math.scss).

/// A robust exponent multiplication which allows for decimal-based exponents.
/// This **fully** replaces Compass' pow() function (allows for float-based exponents).
/// @group Math
/// @param {number} $base
/// @param {number} $exp
/// @link https://gist.github.com/nathancrank/7539155
///
@function pow($base, $exp) {
    @if $exp == floor($exp) {
        $r: 1;
        $s: 0;
        @if $exp < 0 {
            $exp: $exp * -1;
            $s: 1;
        }
        @while $exp > 0 {
            @if $exp % 2 == 1 {
                $r: $r * $base;
            }
            $exp: floor($exp * 0.5);
            $base: $base * $base;
        }
        @return if($s != 0, 1 / $r, $r);
    } @else if $base == 0 and $exp > 0 {
        @return 0;
    } @else {
        $log: log($base);
        $exp: ($log * $exp);
        $exp: cache(_exp, $exp);
        @return $exp;
    }
}

/// @alias pow
/// @group Math
///
@function exponent($base, $exponent) {
    @return pow($base, $exponent);
}

/// A good approximation for $x close to 0. Used with `pow`.
///
@function _exp($x) {
    $ret: 0;
    $i: 1;
    @for $n from 0 to 24 {
        $ret: $ret + $i;
        $i: $i * $x / ($n + 1);
    }
    @return $ret;
}

/// Returns the natural logarithm of a number.
/// @param {number} $x
/// @example
///     $value:   log(2)  // 0.69315
///     $value2:  log(10) // 2.30259
/// @returns {number}
/// @group Math
///
@function log($x, $b: null) {
    @if $b != null {
        @return log($x) / log($b);
    }

    @if $x <= 0 {
        @return 0 / 0;
    }
    $k: nth(frexp($x / $SQRT2), 2);
    $x: $x / ldexp(1, $k);
    $x: ($x - 1) / ($x + 1);
    $x2: $x * $x;
    $i: 1;
    $s: $x;
    $sp: null;
    @while $sp != $s {
        $x: $x * $x2;
        $i: $i + 2;
        $sp: $s;
        $s: $s + $x / $i;
    }
    @return 2 * $s;

    @debug #{$LN2 * $k + _log($x)};
    @return $LN2 * $k + _log($x);
}

/// A good aproximation for $x close to 1
///
/// @group math
///
@function _log($x) {
    $x: ($x - 1) / ($x + 1);
    $x2: $x * $x;
    $i: 1;
    $s: $x;
    $sp: null;
    @while $sp != $s {
        $x: $x * $x2;
        $i: $i + 2;
        $sp: $s;
        $s: $s + $x / $i;
    }
    @return 2 * $s;
}

/// Returns a two-element list containing the normalized fraction and exponent of number.
///
/// @group Math
///
/// @param $x
/// @returns {list} (fraction, exponent)
///
@function frexp($x) {
    $exp: 0;
    @if $x < 0 {
        $x: $x * -1;
    }
    @if $x < 0.5 {
        @while $x < 0.5 {
            $x: $x * 2;
            $exp: $exp - 1;
        }
    } @else if $x >= 1 {
        @while $x >= 1 {
            $x: $x / 2;
            $exp: $exp + 1;
        }
    }
    @return ($x, $exp);
}

/// Returns `$x * 2^$exp`
/// @param {number} $x
/// @param {number} $exp
/// @group Math
///
@function ldexp($x, $exp) {
    $b: if($exp >= 0, 2, 1 / 2);
    @if $exp < 0 {
        $exp: $exp * -1;
    }
    @while $exp > 0 {
        @if $exp % 2 == 1 {
            $x: $x * $b;
        }
        $b: $b * $b;
        $exp: floor($exp * 0.5);
    }
    @return $x;
}

/// Returns the factorial of a non-negative integer.
/// @param {number} $x
/// @group Math
/// @example
///     $value:  fact(0) // 1
///     $value2: fact(8) // 40320
/// @return {Number}
///
@function fact($x) {
    @if $x < 0 or $x != floor($x) {
        @warn "Argument for `fact()` must be a positive integer.";
        @return null;
    }

    $ret: 1;

    @while $x > 0 {
        $ret: $ret * $x;
        $x: ($x - 1);
    }

    @return $ret;
}

/// Greatest Common Divisor calculation (useful for calculating grids and widths).
/// @group Math
/// @param {number} $number-1
/// @param {number} $number-2
/// @returns {number}
/// @link http://rosettacode.org/wiki/Greatest_common_divisor#JavaScript
///
@function gcd($number-1, $number-2) {
    @if $number-2 != 0 {
        @return gcd($number-2, ($number-1 % $number-2));
    } @else {
        @return abs($number-1);
    }
}

/// Find the square root of a value.
/// @group Math
/// @param {number} $base
/// @param {number} $precision [12]
///
@function sqrt($base, $precision: 12) {
    $guess: random(20);
    $root: $guess;

    @for $i from 1 through $precision {
        $root: ($root - (pow($root, 2) - $base) / (2 * $root));
    }
    @return $root;
}

/// @alias sqrt
/// @param $r
/// @group Math
///
@function sqroot($r) {
    $x0: 1; // initial value
    $solution: false;
    $x1: 1;

    @for $i from 1 through 10 {
        @if abs(2 * $x0) < 0.00000000000001 {
            // Don't want to divide by a number smaller than this
            $solution: false;
        }

        $x1: $x0 - ($x0 * $x0 - abs($r)) / (2 * $x0);

        @if (abs($x1 - $x0) / abs($x1)) < 0.0000001 {
            // 7 digit accuracy is desired
            $solution: true;
        }

        $x0: $x1;
    }

    @if $solution == true {
        // If $r is negative, then the output will be multiplied with
        // [i = √-1](http://en.wikipedia.org/wiki/Imaginary_number)
        // (√xy = √x√y) => √-$r = √-1√$r
        @if $r < 0 {
            @return $x1 #{i};
        } @else {
            @return $x1;
        }
    } @else {
        @return "No solution";
    }
}

/// Determines the Sine of an angle.
/// [Reference](https://unindented.org/articles/trigonometry-in-sass/)
/// @group Math
/// @param $angle
/// @returns {number}
///
@function sin($angle) {
    $sin: 0;
    $angle: rad($angle);
    // Iterate a bunch of times.
    @for $i from 0 through 10 {
        $sin: $sin + pow(-1, $i) * pow($angle, (2 * $i + 1)) / fact(2 * $i + 1);
    }
    @return $sin;
}

/// Use linear interpolation to produce a calc value for a particular screen size.
/// @group Math
/// @param {number} $min-screen
/// @param {number} $min-value
/// @param {number} $max-screen
/// @param {number} $max-value
/// @param {string} $unit [vw]
/// @returns {string} - Css `calc()` function.
/// @author Mike Riethmuller
/// @link https://madebymike.com.au/writing/precise-control-responsive-typography/
///
@function calc-interpolation(
    $min-screen,
    $min-value,
    $max-screen,
    $max-value,
    $unit: vw
) {
    $a: ($max-value - $min-value) / ($max-screen - $min-screen);
    $b: $min-value - $a * $min-screen;

    $sign: "+";

    @if ($b < 0) {
        $sign: "-";
        $b: abs($b);
    }

    @return calc(#{$a * 100}#{$unit} #{$sign} #{$b});
}

/// This is a crude Sass port webkits cubic-bezier-webkits function.
/// Will return a "solved" cubic-bezier function for any given `$x`.
/// @author Mike Riethmuller
/// @group math
/// @param {Number} $p1x
/// @param {Number} $p1y
/// @param {Number} $p2x
/// @param {Number} $p2y
/// @param {Number} $x
/// @link https://madebymike.com.au/writing/precise-control-responsive-typography/
///
@function solve-cubic-bezier($p1x, $p1y, $p2x, $p2y, $x) {
    $cy: 3 * $p1y;
    $by: 3 * ($p2y - $p1y) - $cy;
    $ay: 1 - $cy - $by;
    $t: solve-bezier-x($p1x, $p1y, $p2x, $p2y, $x);
    @return (($ay * $t + $by) * $t + $cy) * $t;
}

/// Solves a bezier's `$x` for a given cubic-bezier set.
/// @author Mike Riethmuller
/// @group math
/// @param {Number} $p1x
/// @param {Number} $p1y
/// @param {Number} $p2x
/// @param {Number} $p2y
/// @param {Number} $x
///
@function solve-bezier-x($p1x, $p1y, $p2x, $p2y, $x) {
    $cx: 3 * $p1x;
    $bx: 3 * ($p2x - $p1x) - $cx;
    $ax: 1 - $cx - $bx;

    $t0: 0;
    $t1: 1;
    $t2: $x;
    $x2: 0;
    $res: 1000;

    @while ($t0 < $t1 or $break) {
        $x2: (($ax * $t2 + $bx) * $t2 + $cx) * $t2;
        @if (abs($x2 - $x) < $res) {
            @return $t2;
        }
        @if ($x > $x2) {
            $t0: $t2;
        } @else {
            $t1: $t2;
        }
        $t2: ($t1 - $t0) * 0.5 + $t0;
    }

    @return $t2;
}

/// Linear interpolation
/// @link https://en.wikipedia.org/wiki/Linear_interpolation
/// @group math
/// @param {number} $a
/// @param {number} $b
/// @param {number} $t
///
@function lerp($a, $b, $t) {
    @return $a + ($b - $a) * $t;
}

/// Get the golden ratio from `$base`.
/// @group Math
/// @param {} $base [1]
/// @returns {number}
///
@function golden($base: 1) {
    @return (1/2 + sqrt(5) / 2) * $base;
}

/// @param $angle
/// @group Math
///
@function rad($angle) {
    $unit: unit($angle);
    $unitless: $angle / ($angle * 0 + 1);
    // If the angle has 'deg' as unit, convert to radians.
    @if $unit == deg {
        $unitless: $unitless / 180 * $pi;
    }
    @return $unitless;
}

/// @alias rad
/// @param $angle
/// @group Math
///
@function angle-to-rad($angle) {
    @return rad($angle);
}

// Unused functions
// ------------------------------------
// Hyperbolic sine
// @param $number
// @group Math
// @function sinh($number) {
//     $top: exponent($e, (2 * $number)) - 1;
//     $bottom: 2 * exponent($e, $number);
//     @return  $top / $bottom;
// }

// Determines the Cosine of an angle.
// @group Math
// @param $angle
// @returns {number}
// @function cos($angle) {
//     $cos: 0;
//     $angle: rad($angle);
//     // Iterate a bunch of times.
//     @for $i from 0 through 10 {
//         $cos: $cos + pow(-1, $i) * pow($angle, 2 * $i) / fact(2 * $i);
//     }
//     @return $cos;
// }

// @function _template-string($formatting, $values) {
//     $_return: $string;
//
//     @each $val in $values {
//         @if str-index($_return, '%s') {
//             $_return: str-replace($_return, '%s', $val);
//         }
//     }
//
//     @return $_return;
// }
//
// @function _str-template-extract($template) {
//     $_sliced-string: $template;
//     $_word-list: ();
//     $_index-map: ();
//     $_loops: 0;
//
//     @while (str-index($_sliced-string, '{%')) and ($_loops < 10) {
//         $_first-index: str-index($_sliced-string, '{%');
//         $_replacement: str-slice($_sliced-string, $_first-index + 1);
//         $_second-index: str-index($_replacement, '%}') + $_first-index;
//
//         $_word: str-slice($_sliced-string, $_first-index + 1, $_second-index - 1);
//         $_word-list: append($_word-list, $_word);
//         $_index-map: map-merge(
//             $_index-map,
//             ('#{$_word}': $_first-index $_second-index)
//         );
//
//         $temp-string: str-slice($_sliced-string, 1, $_first-index - 1) + str-slice($_sliced-string, $_second-index + 1);
//
//         $_sliced-string: $temp-string;
//         $_loops: $_loops + 1;
//     }
//
//     // Need this format ('replacement': value);
//     @return $_word-list;
// }

@function format-class-names($string, $values-map) {
    $_return: $string;

    @each $word, $value in $values-map {
        @if ($_return) and (str-index($_return, '{%#{$word}%}')) {
            $_return: str-replace($_return, '{%#{$word}%}', '#{$value}');
        }
    }

    @return $_return;
}

// $class-name: 'grid';
//
// @debug format-class-names('.u-%class%\\@%breakpoint%', ('class': $class-name, 'breakpoint': 'sm'));

// '.u-%class%\\@%breakpoint%', ('class': $class, 'breakpoint': $breakpoint)
